{"version":3,"file":"parse-dotenv.js","sources":["../lib/parse-dotenv.ts"],"sourcesContent":["import { resolve } from \"path\";\nimport { readFileSync } from \"fs\";\n\nconst DEFAULT_ENV_PATH = resolve(process.cwd(), \".env\");\nconst NEWLINE = \"\\n\";\n\ninterface Options {\n  emptyLines: boolean;\n}\n\ninterface EnvObject {\n  [key: string]: any;\n}\n\nconst parseEnv = (\n  path?: string,\n  opts: Options = { emptyLines: false }\n): EnvObject => {\n  try {\n    const env = readFileSync(path || DEFAULT_ENV_PATH, {\n      encoding: \"UTF-8\"\n    });\n    const obj: EnvObject = {};\n    let newlineCount = 0;\n    env\n      .split(NEWLINE)\n      .map(\n        (line): string[] => {\n          if (line) {\n            return line.split(\"=\").map(kv =>\n              kv\n                .trim()\n                .replace(/^(\"|')/, \"\")\n                .replace(/(\"|')$/, \"\")\n            );\n          } else if (opts.emptyLines) {\n            newlineCount++;\n            return [`__EMPTYLINE_${newlineCount}__`, \"\"];\n          } else return [\"\"];\n        }\n      )\n      .filter(item => item.length > 1)\n      .forEach(item => {\n        obj[item[0]] = item[1];\n      });\n    return obj;\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\nexport default parseEnv;\n"],"names":["DEFAULT_ENV_PATH","resolve","process","cwd","path","opts","emptyLines","env","readFileSync","encoding","obj","newlineCount","split","map","line","kv","trim","replace","filter","item","length","forEach","error","Error"],"mappings":"sCAGMA,EAAmBC,UAAQC,QAAQC,MAAO,gCAY9CC,EACAC,kBAAgB,CAAEC,YAAY,YAGtBC,EAAMC,eAAaJ,GAAQJ,EAAkB,CACjDS,SAAU,UAENC,EAAiB,GACnBC,EAAe,SACnBJ,EACGK,MArBS,MAsBTC,aACEC,UACKA,EACKA,EAAKF,MAAM,KAAKC,aAAIE,UACzBA,EACGC,OACAC,QAAQ,SAAU,IAClBA,QAAQ,SAAU,MAEdZ,EAAKC,WAEP,mBADPK,OACyC,IAC7B,CAAC,MAGlBO,gBAAOC,UAAQA,EAAKC,OAAS,IAC7BC,iBAAQF,GACPT,EAAIS,EAAK,IAAMA,EAAK,KAEjBT,EACP,MAAOY,SACD,IAAIC,MAAMD"}